{"version":3,"sources":["../lib/SGListView.js"],"names":[],"mappings":"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","file":"SGListView.js","sourcesContent":["import React, {PropTypes} from 'react';\nimport { ListView, ScrollView } from 'react-native';\nimport SGListViewCell from './SGListViewCell';\n\nvar SGListView = React.createClass({\n\n  /**\n   * Object Lifecycle Methods\n   */\n\n  propTypes: {\n    // Default the propTypes to those as specified by ListView\n    ...ListView.propTypes,\n\n    /**\n     * OVERRIDE LISTVIEW's DEFAULT VALUE: Made component not required, since SGListView will provide one by default\n     *\n     * (props) => renderable\n     *\n     * A function that returns the scrollable component in which the list rows\n     * are rendered. Defaults to returning a ScrollView with the given props.\n     */\n    renderScrollComponent: React.PropTypes.func,\n\n    /**\n     * Number of cells to preeptively render in front of the users scrolling\n     */\n    premptiveLoading: PropTypes.number,\n  },\n\n  getDefaultProps: function() {\n    return {\n      premptiveLoading: 2,\n    }\n  },\n\n  /**\n   * View Lifecycle Methods\n   */\n\n  componentWillMount() {\n    // This object keeps track of the cell data.\n    // NOTE: We don't want to trigger a render pass when updating the data here\n    //       so we don't store this information in this.state.\n    this.cellData = {\n      lastVisibleRow: 0, // keep track of the last row rendered\n    };\n  },\n\n  getNativeListView() {\n    return this.refs.nativeListView;\n  },\n\n  // https://github.com/sghiassy/react-native-sglistview/issues/14\n  getScrollResponder() {\n    return this.refs.nativeListView.getScrollResponder();\n  },\n\n  /**\n   * Render Methods\n   */\n\n  render: function() {\n    return (\n      <ListView {...this.props}\n        ref='nativeListView'\n        renderScrollComponent={this.renderScrollComponent}\n        renderRow={this.renderRow}\n        onChangeVisibleRows={this.onChangeVisibleRows} />\n    );\n  },\n\n  renderScrollComponent: function(props) {\n    if (props.renderScrollComponent) {\n      return props.renderScrollComponent(props);\n    } else {\n      return (\n        <ScrollView {...props} />\n      );\n    }\n  },\n\n  renderRow(rowData, sectionID, rowID) {\n    // Get the user's view\n    var view = this.props.renderRow(rowData, sectionID, rowID);\n\n    // Wrap the user's view in a SGListViewCell for tracking & performance\n    return <SGListViewCell\n              usersView={view}\n              ref={(row) => {\n                // Capture a reference to the cell on creation\n                // We have to do it this way for ListView: https://github.com/facebook/react-native/issues/897\n                PrivateMethods.captureReferenceFor(this.cellData, sectionID, rowID, row);\n              }}/>\n  },\n\n  onChangeVisibleRows(visibleRows, changedRows) {\n    // Update cell visibibility per the changedRows\n    PrivateMethods.updateCellsVisibility(this.cellData, changedRows);\n\n    // Premepty show rows to avoid onscreen flashes\n    PrivateMethods.updateCellsPremptively(this.props, this.cellData, visibleRows);\n\n    // If the user supplied an onChangeVisibleRows function, then call it\n    if (this.props.onChangeVisibleRows) {\n      this.props.onChangeVisibleRows(visibleRows, changedRows);\n    }\n  },\n});\n\n/**\n * Some methods are stored here. The benefit of doing so are:\n * 1. The methods are truly private from the outside (unliked the _methodName pattern)\n * 2. The methods aren't instantiated with every instance\n * 3. They're static and hold 0 state\n * 4. Keeps the class size smaller\n */\nvar PrivateMethods = {\n  captureReferenceFor: function(cellData, sectionId, rowId, row) {\n    if (cellData[sectionId] === undefined) {\n      cellData[sectionId] = {};\n    }\n\n    cellData[sectionId][rowId] = row; // Capture the reference\n  },\n\n  /**\n   * Go through the changed rows and update the cell with their new visibility state\n   */\n  updateCellsVisibility: function(cellData, changedRows) {\n    for (var section in changedRows) {\n      if (changedRows.hasOwnProperty(section)) { // Good JS hygiene check\n        var currentSection = changedRows[section];\n\n        for (var row in currentSection) {\n          if (currentSection.hasOwnProperty(row)) { // Good JS hygiene check\n            var currentCell = cellData[section][row];\n            var currentCellVisibility = currentSection[row];\n\n            // Set the cell's new visibility state\n            if (currentCell && currentCell.setVisibility) {\n              currentCell.setVisibility(currentCellVisibility);\n            }\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * When the user is scrolling up or down - load the cells in the future to make it\n   * so the user doesn't see any flashing\n   */\n  updateCellsPremptively: function(props, cellData, visibleRows) {\n    if (!props.premptiveLoading) {\n      return; // No need to run is preemptive loading is 0 or false\n    }\n\n    if (!cellData.premptiveLoadedCells) {\n      cellData.premptiveLoadedCells = [];\n    };\n\n    // Get the first and last visible rows\n    var firstVisibleRow, lastVisibleRow, firstVisibleSection, lastVisibleSection;\n    for (var section in visibleRows) {\n      for (var row in visibleRows[section]) {\n        if (firstVisibleRow === undefined) {\n          firstVisibleSection = section;\n          firstVisibleRow = Number(row);\n        } else {\n          lastVisibleSection = section;\n          lastVisibleRow = Number(row);\n        }\n\n        /*\n         * Dont consider a cell preemptiveloaded if it is touched by default visibility logic.\n         */\n        var currentCell = cellData[section][row];\n        if (cellData.premptiveLoadedCells) {\n          var i = cellData.premptiveLoadedCells.indexOf(currentCell);\n          if (i >= 0) {\n            cellData.premptiveLoadedCells.splice(i, 1);\n          }\n        };\n      };\n    };\n\n    // Figure out if we're scrolling up or down\n    var isScrollingUp = cellData.firstVisibleRow > firstVisibleRow;\n    var isScrollingDown = cellData.lastVisibleRow < lastVisibleRow;\n\n    var scrollDirectionChanged;\n    if (isScrollingUp && cellData.lastScrollDirection === 'down'){\n      scrollDirectionChanged = true;\n    } else if (isScrollingDown && cellData.lastScrollDirection === 'up') {\n      scrollDirectionChanged = true;\n    }\n\n    // remove the other side's preemptive cells\n    if (scrollDirectionChanged) {\n      var cell;\n      while(cell = cellData.premptiveLoadedCells.pop()) {\n        cell.setVisibility(false);\n      }\n    };\n\n    // Preemptively set cells\n    for (var i = 1; i <= props.premptiveLoading; i++) {\n      var cell;\n\n      if (isScrollingUp){\n        cell = cellData[firstVisibleSection][firstVisibleRow - i];\n      } else if (isScrollingDown) {\n        cell = cellData[lastVisibleSection][lastVisibleRow + i];\n      }\n\n      if (cell) {\n        cell.setVisibility(true);\n        cellData.premptiveLoadedCells.push(cell);\n      } else {\n        break;\n      }\n    }\n\n    cellData.firstVisibleRow = firstVisibleRow; // cache the first seen row\n    cellData.lastVisibleRow = lastVisibleRow; // cache the last seen row\n\n    if (isScrollingUp){\n      cellData.lastScrollDirection = 'up';\n    } else if (isScrollingDown) {\n      cellData.lastScrollDirection = 'down';\n    }\n\n  },\n};\n\nmodule.exports = SGListView;\n"]}