{
  "name": "react-native-sglistview",
  "version": "0.1.4",
  "description": "A React Native module to provide a memory efficent ListView over the native implementation",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "x": "open example/ios/example.xcodeproj"
  },
  "keywords": [
    "ReactNative",
    "ListView"
  ],
  "author": {
    "name": "Shaheen Ghiassy",
    "email": "shaheen.ghiassy@gmail.com",
    "url": "http://shaheenghiassy.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/sghiassy/react-native-sglistview",
  "peerDependencies": {
    "react-native": ">=0.4.0"
  },
  "readme": "# React Native SGListView\n\nSGListView is a memory minded implementation of the React Native's ListView.\n\n## The Problem\n\nThe React Native team has done a tremendous job building a robust platform. One oversight, is the memory performance of their ListView implementation. When scrolling down long lists, the memory footprint increases linearly and will eventually exhaust all available memory. On a device as memory-constrained as a mobile device, this behavior can be a deal breaker for many.\n\n![Native ListView Performance](http://cl.ly/image/1E1Q2M2x1Y3F/Before.png)\nAn example of ListView performance for long lists.\n\n## The Solution\n\nSGListView resolves React Native's ListView memory problem by controlling what's being drawn to the screen and what's kept in memory. When cells are scrolled off screen, SGListView intelligently flushes their internal view and only retains the cell's rendered bounding box - resulting in huge memory gains.\n\n![SGListView Performance](http://cl.ly/image/3e2y0a1C1n0K/After.png)\nAn example of SGListView performance for long lists.\n\n\n## Installation\n\nInstall via npm\n\n```bash\nnpm install react-native-sglistview --save\n```\n\n## Usage\n\nSGListView was designed to be a developer-friendly drop-in replacement for ListView. Simply import the package and change the `ListView` references in the render methods to `SGListView`. Nothing else. No fuss, no muss.\n\nImport SGListView\n\n```js\nvar SGListView = require('react-native-sglistview');\n```\n\nChange references from `ListView` to `SGListView`.\n\nFrom:\n```jsx\n<ListView ... />\n```\nTo:\n```jsx\n<SGListView ... />\n```\n\nDone.\n\n**NOTE**: You still create the datasource using ListView (i.e.: `var dataSource = new ListView.DataSource(...)`)\n\n## Options\n\n  * **premptiveLoading (type: integer)**: SGListView will dump the internal view of each cell as it goes off the screen. Conversely, when the cell comes back on the screen, we repopulate the cell with its view. If this transition happens too late in the process, the user will see a flash on screen as the cell transitions from a blank bounding box to its full view representation. SGListView prevents this from happening by preemptively loading cells before they come on screen. By default, we load 2 cells in the future before they come on screen. SGListView allows you to override the number of cells to load preemptively through the prop *premptiveLoading*. **Note**: Because of this logic, its advised not to use ListView's prop *scrollRenderAheadDistance* as they can be in conflict with one another.\n\n## FAQ\n\n### Does this approach reuse cells?\n\nUnfortunately no. Instead what SGListView does is to dump the internal view of cells as they scroll off screen, so that only a simple bounding box of the cell remains in memory.\n\n### Why do you keep cells around when they go off screen? Why don't you just remove them?\n\nWe keep cells around because we wanted SGListView to be a high-fidelity drop-in replacement for ListView - which meant sacrificing performance for compatibility.\n\nWe wanted pixel perfection between ListView and SGListView. This meant that we had to rely on ListView's underlying CSS engine to keep pixel level fidelity between ListView layouts and SGListView layouts. With flexbox styling, removing a cell from a grid can cause a reflow of all remaining cells and therefore could mess with design fidelity. Keeping the bounding box in memory resolved any and all layout concerns.\n\n### Why didn't you wrap a UICollectionView / UITableView?\n\nOne key goal for this project was to make the final solution platform independent. Using an underlying UICollectionView or UITableView would've tied the implementation to iOS's UIKit and was something we worked to avoid.\n\n## Notice\n\nThis is alpha-version code; use skeptically.\n\n## Authors\n\nShaheen Ghiassy <shaheen.ghiassy@gmail.com>\n\n## Contributing\n\nEvery attempt will be made to review PRs promptly. In addition please follow the below style guide\n\n### Contributing Style Guide\n\n#### Annotate Logic Tests\n\nUse variables / BOOLean values to better annotate logic tests. This makes code more readable and maintainable.\n\nInstead of\n\n```js\nif (evt.x >= box.x1 && evt.x <= box.x2) {\n```\n\ndo\n\n```js\nvar userClickedInsideBox = evt.x >= box.x1 && evt.x <= box.x2;\n\nif (userClickedInsideBox) {\n```\n\n#### Semicolons?\n\nYes, semicolons are required. The lack of semicolons in JS lead to obsure ASI bugs [link](http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript) and [Douglas Crockford says to use them](http://javascript.crockford.com/code.html).\n\n#### Brackets are required\n\nYup\n\n#### Brackets on the same line\n\nDo\n\n```js\nif (test === true) {\n```\n\nNot\n\n```js\nif (test === true)\n{\n```\n\n#### If spacing\n\nDo\n\n```js\nif (test === true) {\n```\n\nNot\n\n```js\nif( test===true ){\n```\n",
  "readmeFilename": "README.md",
  "gitHead": "b2c7f58fa0d5de7a93c23780218375686f73f575",
  "_id": "react-native-sglistview@0.1.4",
  "_shasum": "5998186b86264f242b9939ee4ae8218a42f496c3",
  "_from": "react-native-sglistview@0.1.4"
}
